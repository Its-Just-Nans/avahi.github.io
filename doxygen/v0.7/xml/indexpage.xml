<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>avahi</title>
    <detaileddescription>
<sect1 id="index_1choose_api">
<title>Choosing an API</title>
<para>Avahi provides three programming APIs for integration of mDNS/DNS-SD features into your C progams:</para><para><itemizedlist>
<listitem><para><bold>avahi-core</bold>: an API for embedding a complete mDNS/DNS-SD stack into your software. This is intended for developers of embedded appliances only. We dissuade from using this API in normal desktop applications since it is not a good idea to run multiple mDNS stacks simultaneously on the same host. </para></listitem>
<listitem><para><bold>the D-Bus API</bold>: an extensive D-Bus interface for browsing and registering mDNS/DNS-SD services using avahi-daemon. We recommend using this API for software written in any language other than C (e.g. Python). </para></listitem>
<listitem><para><bold>avahi-client</bold>: a simplifying C wrapper around the D-Bus API. We recommend using this API in C or C++ progams. The D-Bus internals are hidden completely. </para></listitem>
<listitem><para><bold>avahi-gobject</bold>: an object-oriented C wrapper based on GLib&apos;s GObject. We recommd using this API for GNOME/Gtk programs.</para></listitem>
</itemizedlist>
All three APIs are very similar, however avahi-core is the most powerful.</para><para>In addition to the three APIs described above Avahi supports two compatibility libraries:</para><para><itemizedlist>
<listitem><para><bold>avahi-compat-libdns_sd</bold>: the original Bonjour API as documented in the header file &quot;dns_sd.h&quot; by Apple Computer, Inc.</para></listitem>
</itemizedlist>
<itemizedlist>
<listitem><para><bold>avahi-compat-howl</bold>: the HOWL API as released with HOWL 0.9.8 by Porchdog Software.</para></listitem>
</itemizedlist>
Please note that these compatibility layers are incomplete and generally a waste of resources. We strongly encourage everyone to use our native APIs for newly written programs and to port older programs to avahi-client!</para><para>The native APIs (avahi-client and avahi-core) can be integrated into external event loops. We provide adapters for the following event loop implementations:</para><para><itemizedlist>
<listitem><para><bold>avahi-glib</bold>: The GLIB main loop as used by GTk+/GNOME</para></listitem>
</itemizedlist>
<itemizedlist>
<listitem><para><bold>avahi-qt</bold>: The Qt main loop as used by Qt/KDE</para></listitem>
</itemizedlist>
Finally, we provide a high-level Gtk+ GUI dialog called <bold>avahi-ui</bold> for user-friendly browsing for services.</para><para>The doxygen-generated API documentation covers avahi-client (including its auxiliary APIs), the event loop adapters and avahi-ui. For the other APIs please consult the original documentation (for the compatibility APIs) or the header files.</para><para>Please note that the doxygen-generated API documentation of the native Avahi API is not complete. A few definitions that are part of the Avahi API have been removed from this documentation, either because they are only relevant in a very few low-level applications or because they are considered obsolete. Please consult the C header files for all definitions that are part of the Avahi API. Please note that these hidden definitions are considered part of the Avahi API and will stay available in the API in the future.</para></sect1>
<sect1 id="index_1error_reporting">
<title>Error Reporting</title>
<para>Some notes on the Avahi error handling:</para><para><itemizedlist>
<listitem><para>Error codes are negative integers and defined as AVAHI_ERR_xx</para></listitem><listitem><para>If a function returns some kind of non-negative integer value on success, a failure is indicated by returning the error code directly.</para></listitem><listitem><para>If a function returns a pointer of some kind on success, a failure is indicated by returning NULL</para></listitem><listitem><para>The last error number may be retrieved by calling <ref refid="client_8h_1a763d48f8147ab488456705970ea20e44" kindref="member">avahi_client_errno()</ref></para></listitem><listitem><para>Just like the libc errno variable the Avahi errno is NOT reset to AVAHI_OK if a function call succeeds.</para></listitem><listitem><para>You may convert a numeric error code into a human readable string using <ref refid="error_8h_1acb801f36563fde5d25b0b2b2cae8dfe0" kindref="member">avahi_strerror()</ref></para></listitem><listitem><para>The constructor function <ref refid="client_8h_1a07b2a33a3e7cbb18a0eb9d00eade6ae6" kindref="member">avahi_client_new()</ref> returns the error code in a call-by-reference argument</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="index_1event_loop">
<title>Event Loop Abstraction</title>
<para>Avahi uses a simple event loop abstraction layer. A table <ref refid="struct_avahi_poll" kindref="compound">AvahiPoll</ref> which contains function pointers for user defined timeout and I/O condition event source implementations needs to be passed to <ref refid="client_8h_1a07b2a33a3e7cbb18a0eb9d00eade6ae6" kindref="member">avahi_client_new()</ref>. An adapter for this abstraction layer is available for the GLib main loop in the object AvahiGLibPoll. A simple stand-alone implementation is available under the name AvahiSimplePoll. An adpater for the Qt main loop is available from avahi_qt_poll_get().</para></sect1>
<sect1 id="index_1good_publish">
<title>How to Register Services</title>
<para><itemizedlist>
<listitem><para>Subscribe to server state changes. Pass a callback function pointer to <ref refid="client_8h_1a07b2a33a3e7cbb18a0eb9d00eade6ae6" kindref="member">avahi_client_new()</ref>. It will be called whenever the server state changes.</para></listitem><listitem><para>Only register your services when the server is in state AVAHI_SERVER_RUNNING. If you register your services in other server states they might not be accessible since the local host name might not necessarily be established.</para></listitem><listitem><para>Remove your services when the server enters AVAHI_SERVER_COLLISION or AVAHI_SERVER_REGISTERING state. Your services may not be reachable anymore since the local host name is no longer established or is currently in the process of being established.</para></listitem><listitem><para>When registering services, use the following algorithm:<itemizedlist>
<listitem><para>Create a new entry group (i.e. <ref refid="publish_8h_1abb17598f2b6ec3c3f69defdd488d568c" kindref="member">avahi_entry_group_new()</ref>)</para></listitem><listitem><para>Add your service(s)/additional RRs/subtypes (e.g. <ref refid="publish_8h_1acb05a7d3d23a3b825ca77cb1c7d00ce4" kindref="member">avahi_entry_group_add_service()</ref>)</para></listitem><listitem><para>Commit the entry group (i.e. <ref refid="publish_8h_1a2375338d23af4281399404758840a2de" kindref="member">avahi_entry_group_commit()</ref>)</para></listitem></itemizedlist>
</para></listitem><listitem><para>Subscribe to entry group state changes.</para></listitem><listitem><para>If the entry group enters AVAHI_ENTRY_GROUP_COLLISION state the services of the entry group are automatically removed from the server. You may immediately add your services back to the entry group (but with new names, perhaps using <ref refid="alternative_8h_1ae0b973d05cf10ee64ff755cff0b85d14" kindref="member">avahi_alternative_service_name()</ref>) and commit again. Please do not free the entry group and create a new one. This would inhibit some traffic limiting algorithms in mDNS.</para></listitem><listitem><para>When you need to modify your services (i.e. change the TXT data or the port number), use the AVAHI_PUBLISH_UPDATE flag. Please do not free the entry group and create a new one. This would inhibit some traffic limiting algorithms in mDNS. When changing just the TXT data avahi_entry_group_update_txt() is a shortcut for AVAHI_PUBLISH_UPDATE. Please note that you cannot use AVAHI_PUBLISH_UPDATE when changing the service name! Renaming a DNS-SD service is identical to deleting and creating a new one, and that&apos;s exactly what you should do in that case. First call <ref refid="publish_8h_1a1293bbccf878dbeb9916660022bc71b2" kindref="member">avahi_entry_group_reset()</ref> to remove it and then read it normally.</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="index_1good_browse">
<title>How to Browse for Services</title>
<para><itemizedlist>
<listitem><para>For normal applications you need to call <ref refid="lookup_8h_1a52d55a5156a7943012d03e6700880d2b" kindref="member">avahi_service_browser_new()</ref> for the service type you want to browse for. Use <ref refid="lookup_8h_1a904611a4134ceb5919f6bb637df84124" kindref="member">avahi_service_resolver_new()</ref> to acquire service data for a service name.</para></listitem><listitem><para>You can use <ref refid="lookup_8h_1a11e9a5e3dcc5dba1f6fbfd0bfdc30f46" kindref="member">avahi_domain_browser_new()</ref> to get a list of announced browsing domains. Please note that not all domains whith services on the LAN are mandatorily announced.</para></listitem><listitem><para>There is no need to subscribe to server state changes.</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="index_1daemon_dies">
<title>How to Write a Client That Can Deal with Daemon Restarts</title>
<para>With Avahi it is possible to write client applications that can deal with Avahi daemon restarts. To accomplish that make sure to pass AVAHI_CLIENT_NO_FAIL to <ref refid="client_8h_1a07b2a33a3e7cbb18a0eb9d00eade6ae6" kindref="member">avahi_client_new()</ref>&apos;s flags parameter. That way <ref refid="client_8h_1a07b2a33a3e7cbb18a0eb9d00eade6ae6" kindref="member">avahi_client_new()</ref> will succeed even when the daemon is not running. In that case the object will enter AVAHI_CLIENT_CONNECTING state. As soon as the daemon becomes available the object will enter one of the AVAHI_CLIENT_S_xxx states. Make sure to not create browsers or entry groups before the client object has entered one of those states. As usual you will be informed about state changes with the callback function supplied to <ref refid="client_8h_1a07b2a33a3e7cbb18a0eb9d00eade6ae6" kindref="member">avahi_client_new()</ref>. If the client is forced to disconnect from the server it will enter AVAHI_CLIENT_FAILURE state with <ref refid="client_8h_1a763d48f8147ab488456705970ea20e44" kindref="member">avahi_client_errno()</ref> == AVAHI_ERR_DISCONNECTED. Free the AvahiClient object in that case (and all its associated objects such as entry groups and browser objects prior to that) and reconnect to the server anew - again with passing AVAHI_CLIENT_NO_FAIL to <ref refid="client_8h_1a07b2a33a3e7cbb18a0eb9d00eade6ae6" kindref="member">avahi_client_new()</ref>.</para><para>We encourage implementing this in all software where service discovery is not an integral part of application. e.g. use it in all kinds of background daemons, but not necessarily in software like iChat compatible IM software.</para><para>For now AVAHI_CLIENT_NO_FAIL cannot deal with D-Bus daemon restarts.</para></sect1>
<sect1 id="index_1domains">
<title>How to Deal Properly with Browsing Domains</title>
<para>Due to the introduction of wide-area DNS-SD the correct handling of domains becomes more important for Avahi enabled applications. All applications that offer the user a list of services discovered with Avahi should offer some kind of editable drop down box where the user can either enter his own domain or select one of those offered by AvahiDomainBrowser. The default domain to browse should be the one returned by <ref refid="client_8h_1aa6d5c36bc5fd18752b575c15427b52ae" kindref="member">avahi_client_get_domain_name()</ref>. The list of domains returned by AvahiDomainBrowser is assembled by the browsing domains configured in the daemon&apos;s configuration file, the domains announced inside the default domain, the domains set with the environment variable $AVAHI_BROWSE_DOMAINS (colon-seperated) on the client side and the domains set in the XDG configuration file ~/.config/avahi/browse-domains on the client side (seperated by newlines). File managers offering some kind of &quot;Network
Neighborhood&quot; folder should show the entries of the default domain right inside that and offer subfolders for the browsing domains returned by AvahiDomainBrowser. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
